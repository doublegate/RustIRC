name: Master Pipeline

on:
  push:
    branches: [main]
    tags: ['v*.*.*']
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      skip_tests:
        description: 'Skip running tests'
        type: boolean
        default: false
      skip_security:
        description: 'Skip security audit'
        type: boolean  
        default: false
      skip_coverage:
        description: 'Skip code coverage'
        type: boolean
        default: false
      release_type:
        description: 'Release type (only for manual runs)'
        type: choice
        options: [none, patch, minor, major]
        default: none
      rust_version:
        description: 'Rust version to test'
        type: choice
        options: [stable, beta, nightly]
        default: stable

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1
  SCCACHE_GHA_ENABLED: "true"
  RUSTC_WRAPPER: "sccache"

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: ${{ github.event_name == 'pull_request' }}

jobs:
  # Phase 1: Quick validation (fail fast) and initial build
  quick-checks:
    name: Quick Checks & Build
    runs-on: ubuntu-latest
    outputs:
      cache_key: ${{ steps.cache.outputs.cache_key }}
      should_run_tests: ${{ steps.config.outputs.should_run_tests }}
      should_run_security: ${{ steps.config.outputs.should_run_security }}
      should_run_coverage: ${{ steps.config.outputs.should_run_coverage }}
      should_run_release: ${{ steps.config.outputs.should_run_release }}
      release_tag: ${{ steps.config.outputs.release_tag }}
    steps:
    - uses: actions/checkout@v4
    
    - uses: dtolnay/rust-toolchain@stable
      with:
        components: rustfmt, clippy
    
    # Setup sccache for faster compilation
    - name: Run sccache-cache
      uses: mozilla-actions/sccache-action@v0.0.5
    
    - name: Generate cache key
      id: cache
      run: |
        cache_key="shared-${{ runner.os }}-${{ hashFiles('**/Cargo.lock') }}-${{ github.run_id }}"
        echo "cache_key=$cache_key" >> $GITHUB_OUTPUT
    
    - uses: Swatinem/rust-cache@v2
      with:
        key: ${{ steps.cache.outputs.cache_key }}
        shared-key: "master-pipeline"
        save-if: true
    
    - name: Format check
      run: cargo fmt --all -- --check
    
    - name: Clippy check
      run: cargo clippy --all-targets --all-features -- -D warnings
    
    # Build once here to populate the cache for all subsequent jobs
    - name: Build all targets
      run: cargo build --all-features --all-targets --release
    
    # Upload build artifacts for other jobs to use
    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: build-artifacts-${{ runner.os }}
        path: |
          target/release/
          target/debug/
        retention-days: 1
        compression-level: 0  # Fast upload, artifacts deleted after 1 day
    
    - name: Configure pipeline
      id: config
      run: |
        # Determine what should run based on trigger and inputs
        should_run_tests="true"
        should_run_security="true"
        should_run_coverage="false"
        should_run_release="false"
        release_tag=""
        
        # Manual workflow dispatch overrides
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          should_run_tests="${{ !inputs.skip_tests }}"
          should_run_security="${{ !inputs.skip_security }}"
          should_run_coverage="${{ !inputs.skip_coverage }}"
          
          if [ "${{ inputs.release_type }}" != "none" ]; then
            should_run_release="true"
            # Generate release tag based on type
            latest_tag=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
            case "${{ inputs.release_type }}" in
              patch)
                new_tag=$(echo $latest_tag | awk -F. '{$NF = $NF + 1; print}' OFS=.)
                ;;
              minor)  
                new_tag=$(echo $latest_tag | awk -F. '{$(NF-1) = $(NF-1) + 1; $NF = 0; print}' OFS=.)
                ;;
              major)
                new_tag=$(echo $latest_tag | awk -F. '{$1 = substr($1, 2) + 1; $2 = 0; $3 = 0; print "v" $0}' OFS=.)
                ;;
            esac
            release_tag="$new_tag"
          fi
        fi
        
        # Tag push triggers release
        if [[ "${{ github.ref }}" =~ ^refs/tags/v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
          should_run_release="true"
          should_run_coverage="true"  # Full coverage on releases
          release_tag="${{ github.ref_name }}"
        fi
        
        # PR: skip coverage by default to speed up
        if [ "${{ github.event_name }}" = "pull_request" ]; then
          should_run_coverage="false"
        fi
        
        # Main branch: run coverage
        if [ "${{ github.ref }}" = "refs/heads/main" ]; then
          should_run_coverage="true"
        fi
        
        echo "should_run_tests=$should_run_tests" >> $GITHUB_OUTPUT
        echo "should_run_security=$should_run_security" >> $GITHUB_OUTPUT  
        echo "should_run_coverage=$should_run_coverage" >> $GITHUB_OUTPUT
        echo "should_run_release=$should_run_release" >> $GITHUB_OUTPUT
        echo "release_tag=$release_tag" >> $GITHUB_OUTPUT
        
        echo "Pipeline Configuration:"
        echo "  Tests: $should_run_tests"
        echo "  Security: $should_run_security"
        echo "  Coverage: $should_run_coverage" 
        echo "  Release: $should_run_release"
        echo "  Release Tag: $release_tag"

  # Phase 2: Parallel execution of tests, security, and documentation
  test-matrix:
    name: Test Matrix
    needs: quick-checks
    if: needs.quick-checks.outputs.should_run_tests == 'true'
    permissions:
      contents: read
      id-token: write  # Required for codecov OIDC
      issues: write    # Required for security audit
      security-events: write  # Required for security audit
    uses: ./.github/workflows/ci.yml
    with:
      rust_version: ${{ inputs.rust_version || 'stable' }}
      skip_tests: false
      cache_key: ${{ needs.quick-checks.outputs.cache_key }}
    secrets: inherit

  documentation:
    name: Documentation
    # Run in parallel - doesn't need quick-checks to complete
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
    - uses: actions/checkout@v4
    
    - uses: dtolnay/rust-toolchain@stable
      with:
        components: rust-docs
    
    - uses: Swatinem/rust-cache@v2
      with:
        shared-key: "master-pipeline"
        cache-targets: false  # Don't cache build artifacts, just dependencies
    
    - name: Build documentation
      run: cargo doc --all-features --no-deps --document-private-items
      env:
        RUSTDOCFLAGS: "--warn missing-docs"
    
    # Note: Doctests are run in the test-matrix job to avoid duplication
    # They run on all platforms as part of the comprehensive test suite
    
    - name: Generate documentation index
      run: |
        cat > target/doc/index.html << 'EOF'
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="utf-8">
            <title>RustIRC Documentation</title>
            <style>
                body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; margin: 40px; }
                h1 { color: #333; border-bottom: 2px solid #ddd; padding-bottom: 10px; }
                .crate { margin: 20px 0; padding: 15px; border: 1px solid #ddd; border-radius: 5px; }
                .crate h2 { margin-top: 0; color: #0969da; }
                a { color: #0969da; text-decoration: none; }
                a:hover { text-decoration: underline; }
                .description { color: #656d76; font-style: italic; margin-top: 5px; }
            </style>
        </head>
        <body>
            <h1>RustIRC Documentation</h1>
            <p>Modern IRC client written in Rust</p>
            
            <div class="crate">
                <h2><a href="rustirc_core/index.html">rustirc-core</a></h2>
                <div class="description">Core functionality and shared components</div>
            </div>
            
            <div class="crate">
                <h2><a href="rustirc_protocol/index.html">rustirc-protocol</a></h2>
                <div class="description">IRC protocol implementation with parsing and validation</div>
            </div>
            
            <div class="crate">
                <h2><a href="rustirc_gui/index.html">rustirc-gui</a></h2>
                <div class="description">Modern graphical user interface using Iced</div>
            </div>
            
            <div class="crate">
                <h2><a href="rustirc_tui/index.html">rustirc-tui</a></h2>
                <div class="description">Terminal-based user interface using ratatui</div>
            </div>
            
            <div class="crate">
                <h2><a href="rustirc_scripting/index.html">rustirc-scripting</a></h2>
                <div class="description">Lua and Python scripting engine</div>
            </div>
            
            <div class="crate">
                <h2><a href="rustirc_plugins/index.html">rustirc-plugins</a></h2>
                <div class="description">Plugin system for extensions</div>
            </div>
        </body>
        </html>
        EOF
    
    - name: Upload documentation artifacts
      uses: actions/upload-artifact@v4
      with:
        name: documentation
        path: target/doc/
        retention-days: 30

  security-audit:
    name: Security Audit
    # Run in parallel - can check dependencies without waiting for build
    if: github.event.inputs.skip_security != 'true'
    permissions:
      contents: read
      issues: write
      pull-requests: write
      security-events: write
      actions: read
    uses: ./.github/workflows/security-audit.yml
    with:
      ignore_advisories: 'RUSTSEC-2024-0384,RUSTSEC-2024-0436'
      create_issues: ${{ github.event_name != 'pull_request' }}
    secrets: inherit

  # Phase 3: Code coverage (only after tests pass)
  coverage:
    name: Code Coverage
    needs: [quick-checks, test-matrix]
    if: |
      always() && 
      needs.quick-checks.outputs.should_run_coverage == 'true' &&
      needs.test-matrix.result == 'success'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    steps:
    - uses: actions/checkout@v4
    
    - uses: dtolnay/rust-toolchain@stable
    
    - uses: Swatinem/rust-cache@v2
      with:
        key: ${{ needs.quick-checks.outputs.cache_key }}
        shared-key: "master-pipeline"
    
    - name: Cache cargo tools
      uses: actions/cache@v4
      with:
        path: |
          ~/.cargo/bin/cargo-tarpaulin
          ~/.cargo/.crates.toml
          ~/.cargo/.crates2.json
        key: cargo-tools-${{ runner.os }}-tarpaulin
        restore-keys: |
          cargo-tools-${{ runner.os }}-
    
    - name: Install tarpaulin
      run: |
        if ! command -v cargo-tarpaulin &> /dev/null; then
          cargo install cargo-tarpaulin --locked
        else
          echo "cargo-tarpaulin already installed"
        fi
    
    - name: Generate coverage report
      run: cargo tarpaulin --out Xml --all-features --timeout 300 --skip-clean
    
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v5
      with:
        files: ./cobertura.xml
        use_oidc: true
        fail_ci_if_error: true
        verbose: true

  # Phase 4: Build artifacts for release (parallel with coverage)
  build-artifacts:
    name: Build Release Artifacts
    needs: [quick-checks, test-matrix, security-audit]
    if: |
      always() &&
      needs.quick-checks.outputs.should_run_release == 'true' &&
      needs.test-matrix.result == 'success' &&
      (needs.security-audit.result == 'success' || needs.security-audit.result == 'skipped')
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            artifact_name: rustirc-linux-amd64.tar.gz
          - os: ubuntu-latest
            target: aarch64-unknown-linux-gnu
            artifact_name: rustirc-linux-arm64.tar.gz
            cross: true
          - os: windows-latest  
            target: x86_64-pc-windows-msvc
            artifact_name: rustirc-windows-amd64.exe.zip
          - os: macos-latest
            target: x86_64-apple-darwin
            artifact_name: rustirc-macos-amd64.tar.gz
          - os: macos-latest
            target: aarch64-apple-darwin
            artifact_name: rustirc-macos-arm64.tar.gz
    runs-on: ${{ matrix.os }}
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - uses: dtolnay/rust-toolchain@stable
      with:
        targets: ${{ matrix.target }}
    
    # Install cross for cross-compilation
    - name: Install cross
      if: matrix.cross == true
      run: cargo install cross --git https://github.com/cross-rs/cross
    
    # Use shared cache from test phase when possible
    - uses: Swatinem/rust-cache@v2
      with:
        key: ${{ needs.quick-checks.outputs.cache_key }}
        shared-key: "master-pipeline"
        # Save the cache only if we're building something new
        save-if: ${{ github.ref == 'refs/heads/main' }}
    
    - name: Build release binary
      run: |
        if [ "${{ matrix.cross }}" = "true" ]; then
          cross build --release --target ${{ matrix.target }} --bin rustirc
        else
          cargo build --release --target ${{ matrix.target }} --bin rustirc
        fi
    
    - name: Package artifact (Unix)
      if: runner.os != 'Windows'
      run: |
        cd target/${{ matrix.target }}/release
        tar -czf ../../../${{ matrix.artifact_name }} rustirc
    
    - name: Package artifact (Windows)
      if: runner.os == 'Windows'
      run: |
        cd target/${{ matrix.target }}/release
        7z a ../../../${{ matrix.artifact_name }} rustirc.exe
      shell: pwsh
    
    - name: Upload build artifact
      uses: actions/upload-artifact@v4
      with:
        name: ${{ matrix.artifact_name }}
        path: ${{ matrix.artifact_name }}
        retention-days: 30

  # Phase 5: Release (only after all checks pass)
  release:
    name: Create Release
    needs: [quick-checks, test-matrix, security-audit, build-artifacts]
    if: |
      always() &&
      needs.quick-checks.outputs.should_run_release == 'true' &&
      needs.test-matrix.result == 'success' &&
      (needs.security-audit.result == 'success' || needs.security-audit.result == 'skipped') &&
      needs.build-artifacts.result == 'success'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      discussions: write
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Download artifacts
      uses: actions/download-artifact@v4
      with:
        path: artifacts
    
    - name: Prepare release assets
      run: |
        mkdir -p release-assets
        # Find only files (not directories) with proper parentheses for OR condition
        find artifacts -type f \( -name "*.tar.gz" -o -name "*.zip" \) | while read file; do
          echo "Processing: $file"
          cp "$file" release-assets/
          # Generate checksums
          cd release-assets
          filename="$(basename "$file")"
          if command -v shasum >/dev/null; then
            shasum -a 256 "$filename" > "$filename.sha256"
          else
            sha256sum "$filename" > "$filename.sha256"
          fi
          cd ..
        done
        echo "Release assets prepared:"
        ls -la release-assets/
    
    - name: Create or update release
      run: |
        tag_name="${{ needs.quick-checks.outputs.release_tag }}"
        
        # Check if release already exists
        if gh release view "$tag_name" >/dev/null 2>&1; then
          echo "Release $tag_name already exists. Uploading new artifacts only..."
          
          # Upload artifacts to existing release (will replace if they exist)
          for file in release-assets/*; do
            if [[ -f "$file" ]]; then
              echo "Uploading $file to existing release..."
              gh release upload "$tag_name" "$file" --clobber
            fi
          done
        else
          echo "Creating new release $tag_name..."
          
          # Create release notes for new release
          cat > release_notes.md << EOF
        ## Release $tag_name
        
        ### What's Changed
        
        This release includes the latest improvements and bug fixes.
        
        ### Downloads
        
        - **Linux x86_64**: \`rustirc-linux-amd64.tar.gz\`
        - **Linux ARM64**: \`rustirc-linux-arm64.tar.gz\`
        - **Windows x86_64**: \`rustirc-windows-amd64.exe.zip\`  
        - **macOS x86_64**: \`rustirc-macos-amd64.tar.gz\`
        - **macOS ARM64 (M1/M2/M3)**: \`rustirc-macos-arm64.tar.gz\`
        
        ### Verification
        
        All binaries include SHA256 checksums for verification.
        
        ### Installation
        
        1. Download the appropriate binary for your platform
        2. Extract the archive
        3. Run the client: \`./rustirc\` (Unix) or \`rustirc.exe\` (Windows)
        
        For detailed usage instructions, see the [README](https://github.com/doublegate/RustIRC#readme).
        EOF
          
          # Create the new release
          gh release create "$tag_name" \
            --title "RustIRC $tag_name" \
            --notes-file release_notes.md \
            --generate-notes \
            release-assets/*
        fi
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Status reporting job
  pipeline-status:
    name: Pipeline Status
    if: always()
    needs: [quick-checks, test-matrix, security-audit, documentation, coverage, build-artifacts, release]
    runs-on: ubuntu-latest
    steps:
    - name: Report pipeline status
      run: |
        echo "## Master Pipeline Results"
        echo ""
        echo "| Phase | Status | Duration |"
        echo "|-------|--------|----------|" 
        echo "| Quick Checks | ${{ needs.quick-checks.result }} | - |"
        echo "| Tests | ${{ needs.test-matrix.result || 'skipped' }} | - |"
        echo "| Security | ${{ needs.security-audit.result || 'skipped' }} | - |"
        echo "| Documentation | ${{ needs.documentation.result || 'skipped' }} | - |"
        echo "| Coverage | ${{ needs.coverage.result || 'skipped' }} | - |"
        echo "| Build Artifacts | ${{ needs.build-artifacts.result || 'skipped' }} | - |"
        echo "| Release | ${{ needs.release.result || 'skipped' }} | - |"
        echo ""
        
        # Calculate overall status
        overall_status="success"
        if [[ "${{ needs.quick-checks.result }}" == "failure" ]]; then
          overall_status="failure"
        elif [[ "${{ needs.test-matrix.result }}" == "failure" ]]; then
          overall_status="failure"
        elif [[ "${{ needs.security-audit.result }}" == "failure" ]]; then
          overall_status="failure"
        fi
        
        echo "Overall pipeline status: $overall_status"
        
        if [ "$overall_status" = "failure" ]; then
          exit 1
        fi